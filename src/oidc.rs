//! This module handles authentication with the openid connect provider

use crate::config::Config;
use actix_web::{
    cookie::{Cookie, CookieBuilder, SameSite},
    error::{InternalError, UrlGenerationError},
    get,
    http::StatusCode,
    web::{Data, Query},
    Either, HttpRequest, HttpResponse,
};

use oauth2::{
    basic::{BasicErrorResponse, BasicErrorResponseType},
    RequestTokenError,
};
use openidconnect::{
    core::{CoreAuthenticationFlow, CoreClient},
    reqwest::async_http_client,
    AuthorizationCode, CsrfToken, Nonce, PkceCodeChallenge, PkceCodeVerifier, TokenResponse,
};

use redis::{aio::ConnectionManager, AsyncCommands};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use tokio::sync::Mutex;

#[derive(Serialize, Deserialize)]
/// Struct used to serialize and deserialize a state mapped to a nonce and pkce
struct StateStore {
    nonce: Nonce,
    pkce_verifier: PkceCodeVerifier,
}

#[get("/login")]
/// Redirects the User-Agent (browser) to the openid connect identity provider
/// for authentication
async fn login_redirect(
    config: Data<Config>,
    redis: Data<Mutex<ConnectionManager>>,
) -> actix_web::Result<HttpResponse> {
    // afaik is the implemenation of this wrong. Then using
    // `Client::authorize_url` (see below), it passes the plain `CsrfToken`
    // directly into the `state` parameter in the url. But it should provide
    // a hash (e.g. a sha256 hash) of the csrf token instead. The original
    // value should be stored in a httpOnly cookie
    //
    // however, we still use the random function to generate a random string
    let state = CsrfToken::new_random();
    // the hashed state is send in the authorization request uri as `state`
    // parameter
    let state_hash = base64::encode_config(Sha256::digest(state.secret()), base64::URL_SAFE_NO_PAD);

    // recieve the client
    let client: CoreClient = config
        .openid_connect
        .clone()
        .load_client()
        .await
        .map_err(|e| {
            InternalError::new(
                format!(
                    "cannot recieve openid connect identity provider client: {}",
                    e
                ),
                StatusCode::INTERNAL_SERVER_ERROR,
            )
        })?;

    let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();

    let (auth_url, _, nonce) = client
        .authorize_url(
            CoreAuthenticationFlow::AuthorizationCode,
            || CsrfToken::new(state_hash),
            Nonce::new_random,
        )
        .set_pkce_challenge(pkce_challenge)
        .url();

    let redis_state = serde_json::to_string(&StateStore {
        nonce,
        pkce_verifier,
    })?;

    // get the ConnectionManager
    let mut redis = redis.lock().await;
    // the state is connected with the pkce_verifier to request the id token
    // the nonce is used to bind a token to a state
    redis
        // expires in 5 minutes
        .set_ex(
            // prefix it so we have something similar to sql tables
            // this input is trusted because it is generated by the server
            format!("oidc:state:{}", state.secret()),
            redis_state,
            60 * 5,
        )
        .await
        .map_err(|e| {
            InternalError::new(
                format!("cannot store in redis cache: {}", e),
                StatusCode::INTERNAL_SERVER_ERROR,
            )
        })?;

    // the host used as base for the cookie `Domain` attribute
    let host: &str = config
        .openid_connect
        .redirect_url
        .host_str()
        .ok_or(UrlGenerationError::ParseError(url::ParseError::EmptyHost))?;

    // build the state cookie
    let state = Cookie::build("oidc_state", state.secret())
        // because only the redirect_url must be able to read these cookies,
        // the domain as well as the path can be set to exactly that
        .domain(host)
        .path(config.openid_connect.redirect_url.path())
        // from https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite#strict :
        // > Cookies will only be sent in a first-party context and not be
        // > sent along with requests initiated by third party websites.
        // Because the redirect to the callback url is made by a third party
        // website (the identity provider), we cannot use SameSite::Secure
        // instead, we use SameSite::Lax:
        // > Cookies are not sent on normal cross-site subrequests (for
        // > example to load images or frames into a third party site), but
        // > are sent when a **user is navigating to the origin site**
        // > (i.e., when following a link).
        .same_site(SameSite::Lax)
        .secure(true)
        // the cookie does not need to be accessible for javascript and really
        // shouldn't because of XSS attacks
        .http_only(true)
        .finish();

    Ok(HttpResponse::Found()
        .insert_header(("Location", auth_url.as_str()))
        .cookie(state)
        .finish())
}

#[derive(Deserialize)]
struct LoginCallbackInfo {
    /// State hash provided from [`login_redirect`]
    state: String,
    /// code from the openid connect provider used to request the access,
    /// refresh and id token
    code: AuthorizationCode,
}

#[get("/callback")]
async fn login_callback(
    redis: Data<Mutex<ConnectionManager>>,
    config: Data<Config>,
    oidc_response: Either<Query<LoginCallbackInfo>, Query<BasicErrorResponse>>,
    req: HttpRequest,
) -> actix_web::Result<HttpResponse> {
    let mut redis = redis.lock().await;

    // the `oidc_state` cookie set in [`login_redirect`]
    let state = req
        .cookie("oidc_state")
        .ok_or_else(|| InternalError::new("Missing state cookie", StatusCode::BAD_REQUEST))?;

    let mut response = HttpResponse::Found();
    // delete the state since they are one time use only no matter if
    // the request was successful or not
    response.del_cookie(&state);

    match oidc_response {
        Either::Left(info) => {
            let expected_state_hash =
                base64::encode_config(Sha256::digest(&state.value()), base64::URL_SAFE_NO_PAD);

            // if the state's hash in the uri does not match the state in the
            // cookie, there might be an attack and the redirect got intercepted
            if expected_state_hash != info.state {
                return Err(InternalError::new(
                    "State and state cookie do not match",
                    StatusCode::BAD_REQUEST,
                )
                .into());
            }

            // so we dont have to format twice for GET and DEL
            let redis_state = format!("oidc:state:{}", state.value());
            // load the [`StateStore`] from the redis database
            let state: String = redis
                // this input is UNTRUSTED but since it is prefixed and it is
                // not possible to inject commands (e.g. by using \n), it is ok
                .get(&redis_state)
                .await
                // there is no StateStore in the redis database, this could be
                // cuz it expired or it got modified
                .map_err(|_| InternalError::new("Unknown state", StatusCode::BAD_REQUEST))?;
            let state: StateStore = serde_json::from_str(&state).map_err(|_| {
                InternalError::new(
                    "Cannot parse state from redis cache",
                    StatusCode::INTERNAL_SERVER_ERROR,
                )
            })?;
            // in newer redis version, we could use `GETDEL` which would make
            // this command unnessary
            redis
                .del(&redis_state)
                .await
                .map_err(|e| InternalError::new(e, StatusCode::INTERNAL_SERVER_ERROR))?;

            // recieve the client
            let client: CoreClient =
                config
                    .openid_connect
                    .clone()
                    .load_client()
                    .await
                    .map_err(|e| {
                        InternalError::new(
                            format!(
                                "cannot recieve openid connect identity provider client: {}",
                                e
                            ),
                            StatusCode::INTERNAL_SERVER_ERROR,
                        )
                    })?;

            // exchange the code for an access token (PKCE with client secret)
            let token_response = client
                .exchange_code(info.code.clone())
                .set_pkce_verifier(state.pkce_verifier)
                .request_async(async_http_client)
                .await
                .map_err(|e| {
                    if let RequestTokenError::ServerResponse(ref e) = e {
                        if let BasicErrorResponseType::InvalidGrant = e.error() {
                            return InternalError::new(
                                // sent if a `code` is invalid or being
                                // reused. The latter should not ever be the
                                // case because the `state` is one time use and
                                // checked before
                                format!(
                                    concat!("Invalid `code` in request. ", "Server sent: {}"),
                                    e.error_description().unwrap_or(&"None".to_string())
                                ),
                                StatusCode::BAD_REQUEST,
                            );
                        }
                    }
                    // fallback if there's something else
                    // other events shouldn't be triggerable by an user
                    InternalError::new(
                        format!("Cannot request token: {}", e),
                        StatusCode::INTERNAL_SERVER_ERROR,
                    )
                })?;

            // finally the expected id token used for authentication
            let id_token = token_response.id_token().ok_or_else(|| {
                InternalError::new(
                    "openid connect identity provider did not return an id token",
                    StatusCode::INTERNAL_SERVER_ERROR,
                )
            })?;

            let claims = id_token
                .claims(&client.id_token_verifier(), &state.nonce)
                .map_err(|e| {
                    InternalError::new(
                        format!("Invalid id token: {}", e),
                        StatusCode::INTERNAL_SERVER_ERROR,
                    )
                })?;

            // this is the only verification done here (except for siganture
            // validation).
            // the `aud` claim (Audience) and other claims will be validated by
            // the authentication guard
            if claims.nonce() != Some(&state.nonce) {
                return Err(
                    InternalError::new("Invalid nonce in token", StatusCode::BAD_REQUEST).into(),
                );
            }

            info!("Authenticated '{}'", claims.subject().as_str());
            let authentication_cookie = CookieBuilder::new(
                concat!(env!("CARGO_CRATE_NAME"), "_id_token"),
                id_token.to_string(),
            )
            .same_site(SameSite::Strict)
            .http_only(true)
            .secure(true)
            .path("/")
            .finish();
            response.cookie(authentication_cookie).insert_header((
                "Location",
                config.openid_connect.app_redirect_success.as_str(),
            ));
        }
        Either::Right(_) => {
            let mut redirect = config.openid_connect.redirect_url.clone();
            // just redirect with the query provided by the openid connect
            // provider.
            redirect.set_query(Some(req.query_string()));
            response.insert_header(("Location", redirect.as_str()));
        }
    };

    Ok(response.finish())
}
